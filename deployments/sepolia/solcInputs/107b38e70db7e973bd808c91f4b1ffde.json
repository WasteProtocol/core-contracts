{
  "language": "Solidity",
  "sources": {
    "contracts/core/WasteDataProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract WasteDataProvider {\n    // Struct for waste types under each category\n    struct WasteType {\n        uint256 id;\n        string name;\n    }\n\n    // Struct for waste categories\n    struct WasteCategory {\n        uint256 id;\n        string name;\n        uint256 emissionRate; // Emission rate for the category\n        WasteType[] wasteTypes; // Array of waste types in this category\n    }\n\n    // Mapping from category ID to WasteCategory\n    mapping(uint256 => WasteCategory) public wasteCategories;\n\n    // Mapping from waste type ID to the category it belongs to\n    mapping(uint256 => uint256) public wasteTypeToCategory;\n\n    // Address of the contract owner (officer)\n    address public owner;\n\n    // Event emitted when a category is added or updated\n    event CategoryAddedOrUpdated(uint256 indexed categoryId, string name, uint256 emissionRate);\n\n    // Event emitted when a waste type is added to a category\n    event WasteTypeAdded(uint256 indexed categoryId, uint256 wasteTypeId, string name);\n\n    // Event emitted when a waste type is updated\n    event WasteTypeUpdated(uint256 indexed categoryId, uint256 wasteTypeId, string newName);\n\n    // Event emitted when a category is removed\n    event CategoryRemoved(uint256 indexed categoryId);\n\n    // Event emitted when a waste type is removed\n    event WasteTypeRemoved(uint256 indexed categoryId, uint256 wasteTypeId);\n\n    // Modifier to restrict access to the owner\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not authorized\");\n        _;\n    }\n\n    // Constructor to set the contract owner\n    constructor() {\n        owner = msg.sender;\n    }\n\n    // Function to add or update a waste category (onlyOwner)\n    function addOrUpdateCategory(uint256 categoryId, string memory name, uint256 emissionRate) external onlyOwner {\n        WasteCategory storage category = wasteCategories[categoryId];\n        category.id = categoryId;\n        category.name = name;\n        category.emissionRate = emissionRate;\n        emit CategoryAddedOrUpdated(categoryId, name, emissionRate);\n    }\n\n    // Function to add a waste type to a category (onlyOwner)\n    function addWasteTypeToCategory(uint256 categoryId, uint256 wasteTypeId, string memory name) external onlyOwner {\n        WasteCategory storage category = wasteCategories[categoryId];\n        require(category.id != 0, \"Category does not exist\");\n\n        WasteType memory newWasteType = WasteType({\n            id: wasteTypeId,\n            name: name\n        });\n\n        category.wasteTypes.push(newWasteType);\n        wasteTypeToCategory[wasteTypeId] = categoryId; // Map waste type ID to its category\n        emit WasteTypeAdded(categoryId, wasteTypeId, name);\n    }\n\n    // Function to update an existing waste type (onlyOwner)\n    function updateWasteType(uint256 wasteTypeId, string memory newName) external onlyOwner {\n        uint256 categoryId = wasteTypeToCategory[wasteTypeId];\n        require(categoryId != 0, \"WasteType not associated with any category\");\n\n        WasteCategory storage category = wasteCategories[categoryId];\n\n        // Find and update the waste type within the category\n        bool updated = false;\n        for (uint256 i = 0; i < category.wasteTypes.length; i++) {\n            if (category.wasteTypes[i].id == wasteTypeId) {\n                category.wasteTypes[i].name = newName;\n                updated = true;\n                emit WasteTypeUpdated(categoryId, wasteTypeId, newName);\n                break;\n            }\n        }\n\n        require(updated, \"WasteType not found\");\n    }\n\n    // Function to remove a waste category and all its waste types (onlyOwner)\n    function removeCategory(uint256 categoryId) external onlyOwner {\n        WasteCategory storage category = wasteCategories[categoryId];\n        require(category.id != 0, \"Category does not exist\");\n\n        // Remove all waste types from the category\n        for (uint256 i = 0; i < category.wasteTypes.length; i++) {\n            uint256 wasteTypeId = category.wasteTypes[i].id;\n            delete wasteTypeToCategory[wasteTypeId]; // Remove mapping of each waste type\n        }\n\n        // Delete the category itself\n        delete wasteCategories[categoryId];\n\n        emit CategoryRemoved(categoryId);\n    }\n\n    // Function to remove a waste type from a category (onlyOwner)\n    function removeWasteType(uint256 wasteTypeId) external onlyOwner {\n        uint256 categoryId = wasteTypeToCategory[wasteTypeId];\n        require(categoryId != 0, \"WasteType not associated with any category\");\n\n        WasteCategory storage category = wasteCategories[categoryId];\n\n        // Find and remove the waste type within the category\n        bool removed = false;\n        for (uint256 i = 0; i < category.wasteTypes.length; i++) {\n            if (category.wasteTypes[i].id == wasteTypeId) {\n                // Remove the waste type by swapping it with the last element and popping the array\n                category.wasteTypes[i] = category.wasteTypes[category.wasteTypes.length - 1];\n                category.wasteTypes.pop();\n                removed = true;\n                break;\n            }\n        }\n\n        require(removed, \"WasteType not found\");\n        delete wasteTypeToCategory[wasteTypeId]; // Remove mapping\n\n        emit WasteTypeRemoved(categoryId, wasteTypeId);\n    }\n\n    // Function to get waste types for a given category\n    function getWasteTypes(uint256 categoryId) external view returns (WasteType[] memory) {\n        WasteCategory storage category = wasteCategories[categoryId];\n        require(category.id != 0, \"Category does not exist\");\n        return category.wasteTypes;\n    }\n\n    // Function to get the waste category by waste type ID\n    function getCategoryByWasteType(uint256 wasteTypeId) external view returns (WasteCategory memory) {\n        uint256 categoryId = wasteTypeToCategory[wasteTypeId];\n        require(categoryId != 0, \"WasteType not associated with any category\");\n        return wasteCategories[categoryId];\n    }\n\n    // Function to transfer ownership\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"Invalid address\");\n        owner = newOwner;\n    }\n\n    function getCarbonEmissionRate(uint256 wasteTypeId) public view returns (uint256) {\n        uint256 categoryId = wasteTypeToCategory[wasteTypeId];\n        WasteCategory storage category = wasteCategories[categoryId];\n        return category.emissionRate;\n    }\n\n    /**\n     * @dev Sets the carbon emission rate of a specific waste type (for testing purposes)\n     * @param categoryId The ID of the waste category\n     * @param rate The carbon emission rate in g of CO2 per g of waste, scaled by 1e18\n     */\n    function setCarbonEmissionRate(uint256 categoryId, uint256 rate) external onlyOwner {\n        WasteCategory storage category = wasteCategories[categoryId];\n        category.emissionRate  =rate;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates",
          "devdoc",
          "userdoc"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}